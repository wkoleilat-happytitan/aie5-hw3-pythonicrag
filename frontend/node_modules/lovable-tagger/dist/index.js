// src/componentTaggerPlugin.ts
import { parse } from "@babel/parser";
import MagicString from "magic-string";
import path from "path";
var validExtensions = /* @__PURE__ */ new Set([".jsx", ".tsx"]);
function componentTagger() {
  const cwd = process.cwd();
  const stats = {
    totalFiles: 0,
    processedFiles: 0,
    totalElements: 0
  };
  return {
    name: "vite-plugin-component-tagger",
    enforce: "pre",
    async transform(code, id) {
      if (!validExtensions.has(path.extname(id)) || id.includes("node_modules")) {
        return null;
      }
      stats.totalFiles++;
      const relativePath = path.relative(cwd, id);
      try {
        const parserOptions = {
          sourceType: "module",
          plugins: ["jsx", "typescript"],
          errorRecovery: true,
          tokens: true
        };
        let ast;
        try {
          ast = parse(code, parserOptions);
        } catch (parseError) {
          return null;
        }
        const magicString = new MagicString(code);
        let changedElementsCount = 0;
        const { walk } = await import("estree-walker");
        let currentElement = null;
        try {
          walk(ast, {
            enter(node) {
              if (node.type === "JSXElement") {
                currentElement = node;
              }
              if (node.type === "JSXOpeningElement" && node.name.type === "JSXIdentifier") {
                const jsxNode = node;
                const elementName = jsxNode.name.name;
                const line = jsxNode.loc?.start?.line ?? 0;
                const attributes = jsxNode.attributes.reduce((acc, attr) => {
                  if (attr.type === "JSXAttribute") {
                    if (attr.value?.type === "StringLiteral") {
                      acc[attr.name.name] = attr.value.value;
                    } else if (attr.value?.type === "JSXExpressionContainer" && attr.value.expression.type === "StringLiteral") {
                      acc[attr.name.name] = attr.value.expression.value;
                    }
                  }
                  return acc;
                }, {});
                let textContent = "";
                if (currentElement && currentElement.children) {
                  textContent = currentElement.children.map((child) => {
                    if (child.type === "JSXText") {
                      return child.value.trim();
                    } else if (child.type === "JSXExpressionContainer") {
                      if (child.expression.type === "StringLiteral") {
                        return child.expression.value;
                      }
                    }
                    return "";
                  }).filter(Boolean).join(" ").trim();
                }
                const content = {};
                if (textContent) {
                  content.text = textContent;
                }
                if (attributes.placeholder) {
                  content.placeholder = attributes.placeholder;
                }
                if (attributes.className) {
                  content.className = attributes.className;
                }
                magicString.appendLeft(
                  jsxNode.name.end ?? 0,
                  ` data-component-path="${relativePath}" data-component-name="${elementName}" data-component-line="${line}" data-component-file="${path.basename(relativePath)}" data-component-content="${encodeURIComponent(JSON.stringify(content))}"`
                );
                changedElementsCount++;
              }
            },
            leave(node) {
              if (node.type === "JSXElement") {
                currentElement = null;
              }
            }
          });
        } catch (walkError) {
          return null;
        }
        stats.processedFiles++;
        stats.totalElements += changedElementsCount;
        return {
          code: magicString.toString(),
          map: magicString.generateMap({ hires: true })
        };
      } catch (error) {
        if (process.env.NODE_ENV === "development") {
          console.error(`Error processing file ${relativePath}:`, error);
        }
        stats.processedFiles++;
        return null;
      }
    }
  };
}
export {
  componentTagger
};
